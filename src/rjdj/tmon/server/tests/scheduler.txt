##############################################################################
#
# Copyright (c) 2011 Reality Jockey Ltd. and Contributors.
# This file is part of T-Mon.
#
# T-Mon is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# T-Mon is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with T-Mon. If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

=====================================
$ Tests for Scheduler
=====================================

    >>> from django.conf import settings
    >>> from pprint import pprint
    >>> from rjdj.tmon.server.utils.scheduler import Scheduler
    >>> import time    
    >>> import Queue
    
Helper function:
----------------
    >>> queue = Queue.Queue()

    >>> def print_data(data):
    ...     queue.put(data)
    

A Scheduler is responsible for managing the asynchronous request processing. It will, up to a certain thread cap, assing threads to given functions.

The object has to be constructed without any arguments:

    >>> scheduler = Scheduler()

In order to process data, the process method has to be called, passing a function and the desired arguments:
    >>> th = scheduler.process(print_data, ("hello", "world"))
    
    >>> scheduler.join()
    
    >>> while not queue.empty():
    ...     print queue.get()
    ('hello', 'world')
    
Join() closes the ThreadPool and prevents further Threads from being created, hence a new scheduler has to be created:
     
     >>> scheduler = Scheduler()
    
The number of concurrent threads is controlled by the MAX_THREADS settings property.
    >>> settings.MAX_THREADS = 4

After the maximum number of threads has been reached, the rest of the tasks are not being dropped:

    >>> for i in xrange(10):
    ...     th = scheduler.process(print_data, ("hello", "world", i))
    >>> scheduler.join()

    >>> while not queue.empty():
    ...     print queue.get()
    ('hello', 'world', 0)
    ('hello', 'world', 1)
    ('hello', 'world', 2)
    ('hello', 'world', 3)
    ('hello', 'world', 4)
    ('hello', 'world', 5)
    ('hello', 'world', 6)
    ('hello', 'world', 7)
    ('hello', 'world', 8)
    ('hello', 'world', 9)

